/*
* generated by Xtext
*/
package ee.xtext.haxe.ui.contentassist;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor;

import com.google.common.base.Predicates;
import com.google.inject.Inject;

import ee.xtext.haxe.haxe.BlockExpression;
import ee.xtext.haxe.haxe.Expression;
import ee.xtext.haxe.scoping.HaxeScopeProvider;
/**
 * see http://www.eclipse.org/Xtext/documentation/latest/xtext.html#contentAssist on how to customize content assistant
 */
public class HaxeProposalProvider extends AbstractHaxeProposalProvider {
	
	@Inject
	private ReferenceProposalCreator crossReferenceProposalCreator;
	
	@Inject
	private HaxeScopeProvider scopeProvider;
	
	public void completeFeatureCall_Feature(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		CrossReference crossReference = (CrossReference) assignment.getTerminal();
		ParserRule containingParserRule = GrammarUtil.containingParserRule(crossReference);
		
		if (!GrammarUtil.isDatatypeRule(containingParserRule)) {
			
			String ruleName = null;
			if (crossReference.getTerminal() instanceof RuleCall) {
				ruleName = ((RuleCall) crossReference.getTerminal()).getRule().getName();
			}
			
			EReference reference = GrammarUtil.getReference(crossReference);
			
			EObject previousModel = context.getPreviousModel();
			
			if (previousModel.equals(model))
			{
				//find the previous model
				for(Expression expression: ((BlockExpression) model).getExpressions()) {
					ICompositeNode node = NodeModelUtils.findActualNodeFor(expression);
					if (node.getOffset() >= context.getOffset())
					{
						break;
					}
					previousModel = expression;
				}
			} else
			{
				//find the direct child of the model
				while (!previousModel.eContainer().equals(model))
				{
					previousModel = previousModel.eContainer();
				}
				
			}
			int index = model.eContents().indexOf(previousModel);
			
			IScope scope = scopeProvider.getBlockExpressionScope(index + 1, (BlockExpression) model);
			
			crossReferenceProposalCreator.lookupCrossReference(scope, model, reference, acceptor, Predicates.<IEObjectDescription> alwaysTrue(), getProposalFactory(ruleName, context));
		}
	}
}
