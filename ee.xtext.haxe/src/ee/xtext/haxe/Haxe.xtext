grammar ee.xtext.haxe.Haxe hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate haxe "http://www.xtext.ee/haxe/Haxe"

//TODO, we might need to implement AbstractFeatureCall (see xbase.ecore)
//TODO, implement Extensions: var p : {> Point, z : Int } or typedef Point3D = {> Point, var z : Int; }
//TODO, add the correct validation (see ref)

Package:
	('package' name=QualifiedName ';')?
	(imports+=Import | using+=Using)*
	(classes+=Class | interfaces+=Interface | enums+=Enum | typedefs+=Typedef)*;

Import:
	'import' importedNamespace=QualifiedNameWithWildcard ';';

Using:
	'using' importedClass=QualifiedName ';';

Type returns Type:
	Class | Interface | TypeParameter | Enum | Typedef;

Class returns Class:
	private?='private'? 'class' name=ValidID typeParameters=TypeParameters? ('extends' extends=ClassReference)? ('implements' implements+=TypeReference (',' 'implements' implements+=TypeReference)*)?
	'{'
		(
			(constructor=Constructor)? |
			(functions+=FunctionMemberDeclaration)* |	
			(variables+=VariableMemberDeclaration)*	
		)
		
	'}';

Interface returns Interface:
	{Interface}
	(
		private?='private'? 'interface' name=ValidID typeParameters=TypeParameters? ('implements' implements+=InterfaceReference (',' 'implements' implements+=InterfaceReference)*)?
		'{'
			(functions+=FunctionMemberDeclaration)* |	
			(variables+=VariableMemberDeclaration)*	
		'}'
	);

Enum returns Enum:
	private?='private'? 'enum' name=ValidID typeParameters=TypeParameters?
	'{'
		(members+=EnumConstructor)*
	'}';

EnumConstructor:
	name=ValidID ('(' parameters+=FormalParameter (',' parameters+=FormalParameter)* ')')?;

Typedef:
	{Typedef}
	(
		private?='private'? 'typedef' name=ValidID '='
		'{' ('>' extends=TypeReference ',')?
			(functions+=FunctionMemberDeclaration)* |	
			(variables+=VariableMemberDeclaration)*
		'}'
	);

TypeReference returns TypeReference:
	type=[Type|QualifiedName] (=>'<' arguments+=TypeReference (',' arguments+=TypeReference)* '>')?;
	
ClassReference returns TypeReference:
	type=[Class|QualifiedName] (=>'<' arguments+=TypeReference (',' arguments+=TypeReference)* '>')?;

InterfaceReference returns TypeReference:
	type=[Interface|QualifiedName] (=>'<' arguments+=TypeReference (',' arguments+=TypeReference)* '>')?;

VariableDeclaration returns VariableDeclaration:
	{VariableDeclaration} name=ValidID (':' type=TypeReference)? ('=' expression=Expression)?;

VariableMemberDeclaration returns VariableMemberDeclaration:
	{VariableMemberDeclaration} modifier=Modifier 'var' name=ValidID ('(' getter=[FunctionMemberDeclaration|GetterSetterID] ',' setter=[FunctionMemberDeclaration|GetterSetterID] ')')? ':' type=TypeReference ('=' expression=Expression)?;

FunctionMemberDeclaration returns FunctionMemberDeclaration:
	{FunctionMemberDeclaration} modifier=Modifier 'function' name=ValidID '(' (parameters+=FormalParameter (',' parameters+=FormalParameter)*)? ')' (':' returnType=TypeReference)?
		body=BlockExpression;

Constructor returns Constructor:
	{Constructor} modifier=Modifier 'function' 'new' '(' (parameters+=FormalParameter (',' parameters+=FormalParameter)*)? ')'
		body=BlockExpression;

QualifiedNameWithWildcard:
	QualifiedName '.*'?;

QualifiedName:
  ValidID ('.' ValidID)*;
  
ValidID:
	ID;

FeatureID:
	ValidID | 'super' | 'this';

GetterSetterID:
	ValidID | 'default' | 'null' | 'dynamic' | 'never';

Feature returns Feature:
	VariableDeclaration | FormalParameter | FunctionMemberDeclaration | VariableMemberDeclaration;

FormalParameter returns FormalParameter:
	optional?='?'? name=ValidID (':' type=TypeReference)? ('=' defaultValue=Literal)?;

Modifier returns Modifier:
	{Modifier}
	(
		static?='static'? & 
		final?='final'? & 
		dynamic?='dynamic'? & 
		override?='override'? &
		inline?='inline'? & 
		visibility=Visibility?
	);

enum Visibility:
	PUBLIC='public' | PRIVATE='private';

TypeParameters:
	'<' parameters+=TypeParameter (',' parameters+=TypeParameter)* '>';

TypeParameter:
	name=ValidID (':' '(' constraints+=TypeReference (',' constraints+=TypeReference)* ')')?;

Expression returns Expression :
	Assignment;

Assignment returns Expression :
	{Assignment} feature=[Feature|FeatureID] OpSingleAssign value=Assignment |	
	OrExpression (=>({Operation.left=current} feature=OpMultiAssign) right=Assignment)?;

OpSingleAssign:
	'='
;

OpMultiAssign:
	'+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | ">>>=";

OrExpression returns Expression:
	AndExpression (=>({Operation.left=current} feature=OpOr) right=AndExpression)*;

OpOr:
	'||';

AndExpression returns Expression:
	OtherOperatorExpression (=>({Operation.left=current} feature=OpAnd) right=OtherOperatorExpression)*;

OpAnd:
	'&&';

OtherOperatorExpression returns Expression:
	CompareExpression (=>({Operation.left=current} feature=OpOther) right=CompareExpression)*;

OpOther:
	'...';

CompareExpression returns Expression:
	BitwiseExpression (=>({Operation.left=current} feature=OpCompare) right=BitwiseExpression)*;

OpCompare:
	'==' | '!=' | '>=' | '<=' | '>' | '<';

BitwiseExpression returns Expression:
	BitshiftExpression (=>({Operation.left=current} feature=OpBitwise) right=BitshiftExpression)*;

OpBitwise:
	'|' | '&' | '^';

BitshiftExpression returns Expression:
	AddExpression (=>({Operation.left=current} feature=OpBitshift) right=AddExpression)*;

OpBitshift:
	'<<' | '>>' | '>>>';

AddExpression returns Expression:
	SubtractExpression (=>({Operation.left=current} feature=OpAdd) right=SubtractExpression)*;

OpAdd:
	'+';

SubtractExpression returns Expression:
	MultiplyExpression (=>({Operation.left=current} feature=OpSubtract) right=MultiplyExpression)*;

OpSubtract:
	'-';

MultiplyExpression returns Expression:
	DivideExpression (=>({Operation.left=current} feature=OpMultiply) right=DivideExpression)*;

OpMultiply:
	'*';

DivideExpression returns Expression:
	ModuloExpression (=>({Operation.left=current} feature=OpDivide) right=ModuloExpression)*;

OpDivide:
	'/';

ModuloExpression returns Expression:
	UnaryOperation (=>({Operation.left=current} feature=OpModulo) right=UnaryOperation)*;

OpModulo:
	'%';

UnaryOperation returns Expression:
	{UnaryOperation} feature=OpUnary operand=PreIncrementOperation
	| PreIncrementOperation;
		
OpUnary:
	"!" | "-" | "~";
	
PreIncrementOperation returns Expression:
	=>({PreIncrementOperation} feature=OpIncrement operand=PostIncrementOperation) |
	PostIncrementOperation;
	
PostIncrementOperation returns Expression:
	=>({PostIncrementOperation} operand=MemberFeatureCall feature=OpIncrement) |
	MemberFeatureCall;
	
OpIncrement:
	"++" | "--";


MemberFeatureCall returns Expression:
	PrimaryExpression 
	(=>({Assignment.assignable=current} '.' feature=[Feature|FeatureID] OpSingleAssign) value=Assignment
	|=>({ArrayAssignment.assigname=current} '[' feature=Expression ']' OpSingleAssign) value=Assignment
	|=>({MemberFeatureCall.target=current} ".") 
		feature=[Feature|FeatureID] (
			=>explicitOperationCall?='(' 
				(
				    //memberCallArguments+=XShortClosure |
					arguments+=Expression (',' arguments+=Expression)*
				)? 
			')'
		)?
	|=>({ArrayAccess.target=current})
		'[' feature=Expression ']' (
			=>explicitOperationCall?='(' 
				(
				    //memberCallArguments+=XShortClosure |
					arguments+=Expression (',' arguments+=Expression)*
				)? 
			')'
		)?
	)*
;

PrimaryExpression returns Expression:
	BlockExpression |
	ParenthesizedExpression |
	IfExpression |
	WhileExpression |
	DoWhileExpression |
	ForLoopExpression |
	ReturnExpression |
	BreakExpression |
	ContinueExpression |
	ThrowExpression |
	TryCatchExpression |
	SwitchExpression |
	FunctionExpression |
	FeatureCall |
	ConstructorCall |
	Literal
;

BlockExpression returns Expression: 
	{BlockExpression}
	'{'// '[' temp=STRING ']' 
		(expressions+=ExpressionInsideBlock)*
	'}';

ExpressionInsideBlock returns Expression:
	VariableDeclarations ';'? |
	Expression ';'?;

VariableDeclarations returns Expression:
	{VariableDeclarations} 'var' declarations+=VariableDeclaration (',' declarations+=VariableDeclaration)*;

ParenthesizedExpression returns Expression:
	'(' Expression ')';

IfExpression returns Expression:
	{IfExpression}
	'if' '(' if=Expression ')'
	then=Expression
	(=>'else' else=Expression)?;

WhileExpression returns Expression:
	{WhileExpression}
	'while' '(' predicate=Expression ')'
		body=Expression;

DoWhileExpression returns Expression:
	{DoWhileExpression}
   'do'
       body=Expression
   'while' '(' predicate=Expression ')';

ForLoopExpression returns Expression:
	{ForLoopExpression}
	=>('for' '(' declaredParam=FormalParameter 'in' forExpression=Expression ')')
		body=Expression;

ReturnExpression returns Expression :
	{ReturnExpression} 'return' (=>expression=Expression)?;

BreakExpression returns Expression:
	{BreakExpression} 'break';

ContinueExpression returns Expression:
	{BreakExpression} 'continue';

ThrowExpression returns Expression :
	{ThrowExpression} 'throw' expression=Expression;
	
TryCatchExpression returns Expression:
	{TryCatchExpression}
	'try' 
		expression=Expression
	(
		(catchClauses+=CatchClause)+
	);
	
CatchClause:
	=>'catch' '(' declaredParam=FormalParameter ')' expression=Expression;

SwitchExpression returns Expression:
	{SwitchExpression}
	'switch' switch=Expression '{'
		(cases+=CasePart)+
		('default' ':' default=Expression )?
	'}';

CasePart:
	=>'case' cases+=Expression ((',' cases+=Expression)+)? ':' then=Expression;

FunctionExpression returns Expression:
	{FunctionExpression} 'function' '(' (parameters+=FormalParameter (',' parameters+=FormalParameter)*)? ')' (':' returnType=TypeReference)?
		body=BlockExpression;

FeatureCall returns Expression:
	{FeatureCall}
	feature=[Feature|FeatureID]
	(=>explicitOperationCall?='(' 
		(arguments+=Expression)? (',' arguments+=Expression)*
	')')?; 

ConstructorCall returns Expression:
	{ConstructorCall}
	'new' constructor=TypeReference 
	'(' 
		(arguments+=Expression)? (',' arguments+=Expression)*
	')';

Literal returns Expression:
	BooleanLiteral |
	NullLiteral |
	StringLiteral |
	IntLiteral |
	FloatLiteral |
	RegularExpressionLiteral |
	ArrayLiteral |
	ObjectLiteral
;

BooleanLiteral returns Expression:
	{BooleanLiteral} ('false' | isTrue?='true');

NullLiteral returns Expression:
	{NullLiteral} 'null';

FloatLiteral returns Expression:
	{FloatLiteral} value=FLOAT;

IntLiteral returns Expression:
	{IntLiteral} value=(INT|HEX);

StringLiteral returns Expression:
	{StringLiteral} value=STRING;

RegularExpressionLiteral returns Expression:
	{RegularExpressionLiteral} value=REGULAR_EXPRESSION;

ArrayLiteral returns Expression:
	{ArrayLiteral} '[' (elements+=Expression)? (',' elements+=Expression)* ']';

ObjectLiteral returns Expression:
	{ObjectLiteral} '{' elements+=ObjectElement (',' elements+=ObjectElement)* '}';

ObjectElement:
	key=ValidID ':' value=Expression;


terminal ID:
	('a'..'z'|'A'..'Z'|'$'|'_') ('a'..'z'|'A'..'Z'|'$'|'_'|'0'..'9')* ;

terminal HEX returns ecore::EInt : 
	'0' ('x'|'X') HEX_DIGIT+ ;

terminal fragment HEX_DIGIT : 
	('0'..'9'|'a'..'f'|'A'..'F') ;

terminal INT returns ecore::EInt : 
	('0' | '1'..'9' '0'..'9'*) ;

terminal FLOAT returns ecore::EDouble :
	('0'..'9')+ '.' ('0'..'9')* EXPONENT? |
    '.' ('0'..'9')+ EXPONENT? |
    ('0'..'9')+ EXPONENT ;

terminal fragment EXPONENT : 
	('e'|'E') ('+'|'-')? ('0'..'9')+ ;

terminal REGULAR_EXPRESSION:
	'~/' ('\\/' | !'/')+ '/' ('i' | 'g' | 'm' | 's' | 'u')*;
	
terminal STRING: 
	'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
	"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
;
 
terminal ML_COMMENT:
	'/*' -> '*/';
	
terminal SL_COMMENT:
	'//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS:
	(' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER: 
	.;