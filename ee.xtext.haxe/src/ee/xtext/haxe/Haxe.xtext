grammar ee.xtext.haxe.Haxe hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate haxe "http://www.xtext.ee/haxe/Haxe"

/*
 * TODO list:
 * 
 * - Check the ref for validation
 * - Add validation for types. Think of the types that can be extended and implemented
 * - Add validation for variables. non-static variables may not have an initial value
 * - Add default visibility. This depends on the context: example: default for Typedef is public where default for Class is private
 */

Package:
	('package' name=QualifiedName ';')?
	(imports+=Import | using+=Using)*
	(classes+=Class | interfaces+=Interface | typedefs+=Typedef | enums+=Enum | externClasses+=ExternClass)*;

Import:
	'import' importedNamespace=QualifiedNameWithWildcard ';';

Using:
	'using' importedClass=QualifiedName ';';

/**********************
 * CLASSES AND TYPES
 */

Type returns Type:
	Class | Interface | Typedef | Enum | TypeParameter;

Class:
	visibility=Visibility? 'class' name=ValidID typeParameters=TypeParameters? (('extends' extends=TypeReference | 'implements' implements+=TypeReference) (',' 'implements' implements+=TypeReference)*)?
	'{'
		(constructor=ClassConstructor? & (properties+=ClassProperty | methods+=ClassMethod)*)
	'}';

Interface:
	visibility=Visibility? 'interface' name=ValidID typeParameters=TypeParameters? ('implements' implements+=TypeReference (',' 'implements' implements+=TypeReference)*)?
	'{'
		(properties+=InterfaceProperty | methods+=InterfaceMethod)*
	'}';

Typedef:
	visibility=Visibility? 'typedef' name=ValidID '='
	(
		('{' ('>' extends=TypeReference ',')?
			(properties+=TypedefProperty | methods+=TypedefMethod)*
		'}')
		|
		type=TypeReference
	);

Enum:
	visibility=Visibility? 'enum' name=ValidID typeParameters=TypeParameters?
	'{'
		(constructors+=EnumConstructor)*
	'}';

ExternClass:
	'extern' 'class' name=ValidID typeParameters=TypeParameters? ('extends' extends=TypeReference)? (',' 'implements' implements+=TypeReference)*
	'{'
	'}';

TypeParameters:
	'<' parameters+=TypeParameter (',' parameters+=TypeParameter)* '>';

TypeParameter:
	name=ValidID (':' '(' constraints+=TypeReference (',' constraints+=TypeReference)* ')')?;

TypeReferenceOrMethodSignature returns Reference:
	TypeReference 
	(=>({MethodSignature.argumentTypes+=current} '->') (=>(argumentTypes+=TypeReference '->'))* returnType=TypeReference /* ) */)?;

TypeReference returns Reference:
	{TypeReference}
	type=[Type|QualifiedName] (=>'<' arguments+=TypeReference (',' arguments+=TypeReference)* '>')?;

/**********************
 * MEMBERS
 */

enum Visibility:
	PRIVATE='private' | PUBLIC='public';

MethodModifier:
	{Modifier}
	(
		static?='static'? & 
		final?='final'? & 
		dynamic?='dynamic'? & 
		override?='override'? &
		inline?='inline'? & 
		visibility=Visibility?
	);
	
PropertyModifier:
	{Modifier}
	(
		static?='static'? & 
		visibility=Visibility?
	);

OptionalParameter:
	Parameter optional?='?'?;

Parameter:
	name=ValidID (':' type=TypeReferenceOrMethodSignature)? ('=' defaultValue=Literal)?;

ClassConstructor:
	{ClassConstructor} visibility=Visibility? 'function' 'new' '(' (parameters+=OptionalParameter (',' parameters+=OptionalParameter)*)? ')';

ClassProperty:
	modifier=PropertyModifier 'var' name=ValidID ('(' getter=[ClassMethod|GetterSetterID] ',' setter=[ClassMethod|GetterSetterID] ')')? (':' type=TypeReferenceOrMethodSignature)? ('=' expression=Expression)?;

ClassMethod:
	modifier=MethodModifier 'function' name=ValidID '(' (parameters+=OptionalParameter (',' parameters+=OptionalParameter)*)? ')' (':' returnType=TypeReferenceOrMethodSignature)?
		body=BlockExpression;

InterfaceProperty:
	'var' name=ValidID ('(' getter=[ClassMethod|GetterSetterID] ',' setter=[ClassMethod|GetterSetterID] ')')? ':' type=TypeReferenceOrMethodSignature;

InterfaceMethod:
	'function' name=ValidID '(' (parameters+=OptionalParameter (',' parameters+=OptionalParameter)*)? ')' (':' returnType=TypeReferenceOrMethodSignature)?;

TypedefProperty:
	visibility=Visibility? 'var' name=ValidID ('(' getter=[ClassMethod|GetterSetterID] ',' setter=[ClassMethod|GetterSetterID] ')')? (':' type=TypeReferenceOrMethodSignature)?;

TypedefMethod:
	visibility=Visibility? 'function' name=ValidID '(' (parameters+=OptionalParameter (',' parameters+=OptionalParameter)*)? ')' (':' returnType=TypeReferenceOrMethodSignature)?;

EnumConstructor:
	name=ValidID ('(' parameters+=OptionalParameter (',' parameters+=OptionalParameter)* ')')?;

Feature returns Feature:
	Type | Parameter | VariableDeclaration |
	ClassMethod | ClassProperty |
	InterfaceMethod | InterfaceProperty |
	TypedefMethod | TypedefProperty |
	EnumConstructor;

/**********************
 * EXPRESSIONS - OPERATORS
 */

Expression returns Expression :
	Assignment;

Assignment returns Expression :
	{Assignment} feature=[Feature|FeatureID] OpSingleAssign value=Assignment |	
	OrExpression (=>({Operation.left=current} feature=OpMultiAssign) right=Assignment)?;

OpSingleAssign:
	'='
;

OpMultiAssign:
	'+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | ">>>=";

OrExpression returns Expression:
	AndExpression (=>({Operation.left=current} feature=OpOr) right=AndExpression)*;

OpOr:
	'||';

AndExpression returns Expression:
	OtherOperatorExpression (=>({Operation.left=current} feature=OpAnd) right=OtherOperatorExpression)*;

OpAnd:
	'&&';

OtherOperatorExpression returns Expression:
	CompareExpression (=>({Operation.left=current} feature=OpOther) right=CompareExpression)*;

OpOther:
	'...';

CompareExpression returns Expression:
	BitwiseExpression (=>({Operation.left=current} feature=OpCompare) right=BitwiseExpression)*;

OpCompare:
	'==' | '!=' | '>=' | '<=' | '>' | '<';

BitwiseExpression returns Expression:
	BitshiftExpression (=>({Operation.left=current} feature=OpBitwise) right=BitshiftExpression)*;

OpBitwise:
	'|' | '&' | '^';

BitshiftExpression returns Expression:
	AddExpression (=>({Operation.left=current} feature=OpBitshift) right=AddExpression)*;

OpBitshift:
	'<<' | '>>' | '>>>';

AddExpression returns Expression:
	SubtractExpression (=>({Operation.left=current} feature=OpAdd) right=SubtractExpression)*;

OpAdd:
	'+';

SubtractExpression returns Expression:
	MultiplyExpression (=>({Operation.left=current} feature=OpSubtract) right=MultiplyExpression)*;

OpSubtract:
	'-';

MultiplyExpression returns Expression:
	DivideExpression (=>({Operation.left=current} feature=OpMultiply) right=DivideExpression)*;

OpMultiply:
	'*';

DivideExpression returns Expression:
	ModuloExpression (=>({Operation.left=current} feature=OpDivide) right=ModuloExpression)*;

OpDivide:
	'/';

ModuloExpression returns Expression:
	UnaryOperation (=>({Operation.left=current} feature=OpModulo) right=UnaryOperation)*;

OpModulo:
	'%';

UnaryOperation returns Expression:
	{UnaryOperation} feature=OpUnary operand=PreIncrementOperation
	| PreIncrementOperation;
		
OpUnary:
	"!" | "-" | "~";
	
PreIncrementOperation returns Expression:
	=>({PreIncrementOperation} feature=OpIncrement operand=PostIncrementOperation) |
	PostIncrementOperation;
	
PostIncrementOperation returns Expression:
	=>({PostIncrementOperation} operand=MemberFeatureCall feature=OpIncrement) |
	MemberFeatureCall;
	
OpIncrement:
	"++" | "--";

/**********************
 * EXPRESSIONS - OTHER
 */

MemberFeatureCall returns Expression:
	PrimaryExpression 
	(=>({Assignment.assignable=current} '.' feature=[Feature|FeatureID] OpSingleAssign) value=Assignment
	|=>({ArrayAssignment.assigname=current} '[' feature=Expression ']' OpSingleAssign) value=Assignment
	|=>({MemberFeatureCall.target=current} '.') 
		feature=[Feature|FeatureID] (
			=>explicitOperationCall?='(' 
				(
					arguments+=Expression (',' arguments+=Expression)*
				)? 
			')'
		)?
	|=>({ArrayAccess.target=current})
		'[' feature=Expression ']' (
			=>explicitOperationCall?='(' 
				(
					arguments+=Expression (',' arguments+=Expression)*
				)? 
			')'
		)?
	)*
;

PrimaryExpression returns Expression:
	BlockExpression |
	ParenthesizedExpression |
	IfExpression |
	WhileExpression |
	DoWhileExpression |
	ForLoopExpression |
	ReturnExpression |
	BreakExpression |
	ContinueExpression |
	ThrowExpression |
	TryCatchExpression |
	SwitchExpression |
	FunctionExpression |
	FeatureCall |
	ConstructorCall |
	Literal
;

BlockExpression returns Expression: 
	{BlockExpression}
	'{'
		(expressions+=ExpressionInsideBlock ';'?)*
	'}';

ExpressionInsideBlock returns Expression:
	VariableDeclarations | Expression;

VariableDeclarations returns Expression:
	{VariableDeclarations} 'var' declarations+=VariableDeclaration (',' declarations+=VariableDeclaration)*;

VariableDeclaration returns VariableDeclaration:
	{VariableDeclaration} name=ValidID (':' type=TypeReferenceOrMethodSignature)? ('=' expression=Expression)?;

ParenthesizedExpression returns Expression:
	'(' Expression ')';

FunctionExpression returns Expression:
	{FunctionExpression} 'function' '(' (parameters+=OptionalParameter (',' parameters+=OptionalParameter)*)? ')' (':' returnType=TypeReferenceOrMethodSignature)?
		body=BlockExpression;

FeatureCall returns Expression:
	{FeatureCall}
	feature=[Feature|FeatureID]
	(=>explicitOperationCall?='(' 
		(arguments+=Expression)? (',' arguments+=Expression)*
	')')?; 

ConstructorCall returns Expression:
	{ConstructorCall}
	'new' constructor=TypeReference
	'(' 
		(arguments+=Expression)? (',' arguments+=Expression)*
	')';

/**********************
 * EXPRESSIONS - CONTROL FLOW
 */

IfExpression returns Expression:
	{IfExpression}
	'if' '(' if=Expression ')'
	then=Expression
	(=>'else' else=Expression)?;

WhileExpression returns Expression:
	{WhileExpression}
	'while' '(' predicate=Expression ')'
		body=Expression;

DoWhileExpression returns Expression:
	{DoWhileExpression}
   'do'
       body=Expression
   'while' '(' predicate=Expression ')';

ForLoopExpression returns Expression:
	{ForLoopExpression}
	=>('for' '(' declaredParam=Parameter 'in' forExpression=Expression ')')
		body=Expression;

TryCatchExpression returns Expression:
	{TryCatchExpression}
	'try' 
		expression=Expression
	(
		(catchClauses+=CatchClause)+
	);
	
CatchClause:
	=>'catch' '(' declaredParam=Parameter ')' expression=Expression;

SwitchExpression returns Expression:
	{SwitchExpression}
	'switch' switch=Expression '{'
		(cases+=CasePart)+
		('default' ':' default=CasePartExpressions)?
	'}';

CasePart:
	=>'case' cases+=Expression ((',' cases+=Expression)+)? ':' then=CasePartExpressions;

CasePartExpressions:
	{CasePartExpressions} (expressions+=ExpressionInsideBlock ';'?)*;

ReturnExpression returns Expression :
	{ReturnExpression} 'return' (=>expression=Expression)?;

BreakExpression returns Expression:
	{BreakExpression} 'break';

ContinueExpression returns Expression:
	{BreakExpression} 'continue';

ThrowExpression returns Expression :
	{ThrowExpression} 'throw' expression=Expression;
	
/**********************
 * EXPRESSIONS - LITERALS
 */

Literal returns Expression:
	BooleanLiteral |
	NullLiteral |
	StringLiteral |
	NumberLiteral |
	RegularExpressionLiteral |
	ArrayLiteral |
	ObjectLiteral
;

BooleanLiteral returns Expression:
	{BooleanLiteral} ('false' | isTrue?='true');

NullLiteral returns Expression:
	{NullLiteral} 'null';

NumberLiteral returns Expression:
	{NumberLiteral} value=Number;

Number hidden():
    =>(INT? '.' (INT|EXPONENT_FLOAT)) |
    HEX	|
    EXPONENT_FLOAT |
    INT;

StringLiteral returns Expression:
	{StringLiteral} value=STRING;

RegularExpressionLiteral returns Expression:
	{RegularExpressionLiteral} value=REGULAR_EXPRESSION;

ArrayLiteral returns Expression:
	{ArrayLiteral} '[' (elements+=Expression)? (',' elements+=Expression)* ']';

ObjectLiteral returns Expression:
	{ObjectLiteral} '{' elements+=ObjectElement (',' elements+=ObjectElement)* '}';

ObjectElement:
	key=ValidID ':' value=Expression;

/**********************
 * NAMES AND IDS
 */

QualifiedNameWithWildcard:
	QualifiedName '.*'?;

QualifiedName:
  ValidID ('.' ValidID)*;
  
ValidID:
	ID;

FeatureID:
	ValidID | 'super' | 'this';

GetterSetterID:
	ValidID | 'default' | 'null' | 'dynamic' | 'never';


/**********************
 * TERMINALS
 */

terminal ID:
	('a'..'z'|'A'..'Z'|'$'|'_') ('a'..'z'|'A'..'Z'|'$'|'_'|'0'..'9')* ;

// The hex and exponent float terminals are needed because we would otherwise get INT and ID
terminal EXPONENT_FLOAT:
	INT EXPONENT;

terminal fragment EXPONENT: 
	('e'|'E') ('+'|'-')? INT ;

terminal HEX returns ecore::EInt : 
	'0' ('x'|'X') HEX_DIGIT+ ;

terminal fragment HEX_DIGIT : 
	('0'..'9'|'a'..'f'|'A'..'F') ;
	
terminal INT returns ecore::EInt : 
	('0'..'9')+;

terminal REGULAR_EXPRESSION:
	'~/' ('\\/' | !'/')+ '/' ('i' | 'g' | 'm' | 's' | 'u')*;
	
terminal STRING: 
	'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
	"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
;
 
terminal ML_COMMENT:
	'/*' -> '*/';
	
terminal SL_COMMENT:
	'//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS:
	(' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER: 
	.;