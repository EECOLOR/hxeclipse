grammar ee.xtext.haxe.Haxe hidden(WS, ML_COMMENT, SL_COMMENT, CONDITIONAL_IF, CONDITIONAL_ELSE, CONDITIONAL_ELSE_IF, CONDITIONAL_END)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate haxe "http://www.xtext.ee/haxe/Haxe"

/*
 * TODO list:
 * 
 * - Implement else if
 * 
 * - Check the ref for validation
 * - Add validation for types. Think of the types that can be extended and implemented
 * - Add validation for variables. non-static variables may not have an initial value
 * - Add default visibility. This depends on the context: example: default for Typedef is public where default for Class is private
 * - Add validation for metadata
 */

Package:
	('package' name=QualifiedName ';')?
	(imports+=Import | using+=Using)*
	(classes+=Class | interfaces+=Interface | typedefs+=Typedef | enums+=Enum | externClasses+=ExternClass)*;

Import:
	'import' importedNamespace=QualifiedNameWithWildcard ';';

Using:
	'using' importedClass=QualifiedName ';';

/**********************
 * CONDITIONAL COMPILATION (just the parsing)
 */

terminal CONDITIONAL_IF:
	'#if' WS? CONDITIONAL_EXPRESSION;
	
terminal CONDITIONAL_ELSE:
	'#else';
	
terminal CONDITIONAL_ELSE_IF:
	'#elseif' WS? CONDITIONAL_EXPRESSION;

terminal fragment CONDITIONAL_EXPRESSION:
	'!'? ('(' (!')')+ ')' | ID);

terminal CONDITIONAL_END:
	'#end';

/**********************
 * CLASSES AND TYPES
 */

Type returns Type:
	Class | Interface | Typedef | Enum | ExternClass | TypeParameter;

Class:
	metadata=Metadata?
	visibility=Visibility? 'class' name=ValidID typeParameters=TypeParameters? (('extends' extends=ParameterizedTypeReference | 'implements' implements+=ParameterizedTypeReference) (',' 'implements' implements+=ParameterizedTypeReference)*)?
	'{'
		(constructor=ClassConstructor? & (properties+=ClassProperty | methods+=ClassMethod)*)
	'}';

Interface:
	metadata=Metadata?
	extern='extern'? visibility=Visibility? 'interface' name=ValidID typeParameters=TypeParameters? ('implements' implements+=ParameterizedTypeReference (',' 'implements' implements+=ParameterizedTypeReference)*)?
	'{'
		(properties+=InterfaceProperty | methods+=InterfaceMethod)*
	'}';

Typedef:
	metadata=Metadata?
	visibility=Visibility? 'typedef' name=ValidID typeParameters=TypeParameters? '='
	(
		('{' ('>' extends=ParameterizedTypeReference ',')?
			(properties+=TypedefProperty | methods+=TypedefMethod)*
		'}')
		|
		type=ParameterizedTypeReference
	);

Enum:
	metadata=Metadata?
	extern='extern'? visibility=Visibility? 'enum' name=ValidID typeParameters=TypeParameters?
	'{'
		(constructors+=EnumConstructor)*
	'}';

ExternClass:
	metadata=Metadata?
	visibility=Visibility? 'extern' 'class' name=ValidID typeParameters=TypeParameters? (('extends' extends=ParameterizedTypeReference | 'implements' implements+=ParameterizedTypeReference) (',' 'implements' implements+=ParameterizedTypeReference)*)?
	'{'
		(constructor=ExternClassConstructor? & properties+=ExternClassProperty* & methods+=ExternClassMethod*)
	'}';

TypeParameters:
	'<' parameters+=TypeParameter (',' parameters+=TypeParameter)* '>';

TypeParameter:
	name=ValidID (':' '(' constraints+=ParameterizedTypeReference (',' constraints+=ParameterizedTypeReference)* ')')?;

TypeReference:
	MethodSignature | TypedefType;

MethodSignature returns Reference:
	ParameterizedTypeReference 
	(=>({MethodSignature.argumentTypes+=current} '->') (=>(argumentTypes+=ParameterizedTypeReference '->'))* returnType=ParameterizedTypeReference)?;

ParameterizedTypeReference returns Reference:
	{ParameterizedTypeReference}
	=>(type=[Type|QualifiedName] ('<' arguments+=TypeReference (',' arguments+=TypeReference)* '>')?);

TypedefType returns Reference:
	{TypedefType}
	('{' 
		properties+=TypedefTypeProperty (',' properties+=TypedefTypeProperty)*
	'}');

TypedefTypeProperty:
	name=ValidID ':' type=TypeReference;

/**********************
 * METADATA
 */

Metadata:
	'@' compiler?=':' name=ValidID (=>('(' body=MetadataExpression? ')'))?;

MetadataExpression returns Expression:
	StringLiteral |
	NumberLiteral |
	RegularExpressionLiteral;

/**********************
 * MEMBERS
 */

enum Visibility:
	PRIVATE='private' | PUBLIC='public';

MethodModifier:
	{Modifier}
	(
		static?='static'? & 
		final?='final'? & 
		dynamic?='dynamic'? & 
		override?='override'? &
		inline?='inline'? & 
		visibility=Visibility?
	);
	
PropertyModifier:
	{Modifier}
	(
		static?='static'? & 
		visibility=Visibility?
	);

Parameter:
	name=ValidID (':' type=TypeReference)? ('=' defaultValue=Literal)?;

OptionalParameter returns Parameter:
	optional?='?'? name=ValidID (':' type=TypeReference)? ('=' defaultValue=Literal)?;

ClassConstructor:
	{ClassConstructor}
	metadata=Metadata? 
	visibility=Visibility? 'function' 'new' '(' (parameters+=OptionalParameter (',' parameters+=OptionalParameter)*)? ')' (':' returnType=TypeReference)? 
		body=BlockExpression ';'?;

ClassProperty:
	metadata=Metadata?
	modifier=PropertyModifier 'var' name=ValidID ('(' getter=GetterSetter ',' setter=GetterSetter ')')? (':' type=TypeReference)? ('=' expression=Expression)? ';'?;

ClassMethod returns Method:
	metadata=Metadata?
	modifier=MethodModifier 'function' name=ValidID typeParameters=TypeParameters? '(' (parameters+=OptionalParameter (',' parameters+=OptionalParameter)*)? ')' (':' returnType=TypeReference)?
		untyped?='untyped'? body=BlockExpression ';'?;

InterfaceProperty:
	metadata=Metadata?
	'var' name=ValidID ('(' getter=GetterSetter ',' setter=GetterSetter ')')? ':' type=TypeReference ';'?;

InterfaceMethod returns Method:
	metadata=Metadata?
	'function' name=ValidID typeParameters=TypeParameters? '(' (parameters+=OptionalParameter (',' parameters+=OptionalParameter)*)? ')' (':' returnType=TypeReference)? ';'?;

TypedefProperty:
	metadata=Metadata?
	visibility=Visibility? 'var' name=ValidID ('(' getter=GetterSetter ',' setter=GetterSetter ')')? (':' type=TypeReference)? ';'?;

TypedefMethod returns Method:
	metadata=Metadata?
	visibility=Visibility? 'function' name=ValidID typeParameters=TypeParameters? '(' (parameters+=OptionalParameter (',' parameters+=OptionalParameter)*)? ')' (':' returnType=TypeReference)? ';'?;

EnumConstructor:
	metadata=Metadata?
	name=ValidID ('(' parameters+=OptionalParameter (',' parameters+=OptionalParameter)* ')')? ';'?;

ExternClassConstructor:
	{ExternClassConstructor}
	metadata=Metadata? 
	visibility=Visibility? 'function' 'new' '(' (parameters+=OptionalParameter (',' parameters+=OptionalParameter)*)? ')' (':' returnType=TypeReference)? ';'?;

ExternClassProperty:
	metadata=Metadata?
	modifier=PropertyModifier 'var' name=ValidID ('(' getter=GetterSetter ',' setter=GetterSetter ')')? (':' type=TypeReference)? ('=' expression=Expression)? ';'?;

ExternClassMethod returns Method:
	metadata=Metadata?
	modifier=MethodModifier 'function' name=ValidID typeParameters=TypeParameters? '(' (parameters+=OptionalParameter (',' parameters+=OptionalParameter)*)? ')' (':' returnType=TypeReference)? 
		('untyped' body=BlockExpression)? ';'?;

GetterSetter:
	ClassMethodReference | GetterSetterLiteral;

ClassMethodReference:
	reference=[Method|ValidID];

GetterSetterLiteral:
	value=('default' | 'null' | 'dynamic' | 'never');

Feature returns Feature:
	Type | Parameter | VariableDeclaration |
	ClassMethod | ClassProperty |
	InterfaceMethod | InterfaceProperty |
	TypedefMethod | TypedefProperty |
	EnumConstructor |
	ExternClassMethod | ExternClassProperty;

/**********************
 * EXPRESSIONS - OPERATORS
 */

Expression returns Expression :
	ShortIfExpression |
	{CastExpression} 'cast' (target=Expression | =>('(' target=Expression ',' type=TypeReference ')')) |
	{UntypedExpression} 'untyped' target=Expression;

ShortIfExpression returns Expression:
	Assignment (=>({IfExpression.if=current} '?' then=Expression ':' else=Expression))?;

Assignment returns Expression :
	{Assignment} feature=[Feature|FeatureID] OpSingleAssign value=Assignment |	
	OrExpression (=>({Operation.left=current} feature=OpMultiAssign right=Assignment))?;

OpSingleAssign:
	'='
;

OpMultiAssign hidden():
	'+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<''<''=' | '>''>''>'?'=';

OrExpression returns Expression:
	AndExpression (=>({Operation.left=current} feature=OpOr) right=AndExpression)*;

OpOr:
	'||';

AndExpression returns Expression:
	OtherOperatorExpression (=>({Operation.left=current} feature=OpAnd) right=OtherOperatorExpression)*;

OpAnd:
	'&&';

OtherOperatorExpression returns Expression:
	CompareExpression (=>({Operation.left=current} feature=OpOther) right=CompareExpression)*;

OpOther:
	'...';

CompareExpression returns Expression:
	BitwiseExpression (=>({Operation.left=current} feature=OpCompare right=BitwiseExpression))*;

OpCompare hidden():
	'==' | '!=' | '>''='? | '<''='?;

BitwiseExpression returns Expression:
	BitshiftExpression (=>({Operation.left=current} feature=OpBitwise) right=BitshiftExpression)*;

OpBitwise:
	'|' | '&' | '^';

BitshiftExpression returns Expression:
	AddExpression (=>({Operation.left=current} feature=OpBitshift right=AddExpression))*;

OpBitshift hidden():
	'<''<' | '>''>''>'?;

AddExpression returns Expression:
	SubtractExpression (=>({Operation.left=current} feature=OpAdd) right=SubtractExpression)*;

OpAdd:
	'+';

SubtractExpression returns Expression:
	MultiplyExpression (=>({Operation.left=current} feature=OpSubtract) right=MultiplyExpression)*;

OpSubtract:
	'-';

MultiplyExpression returns Expression:
	DivideExpression (=>({Operation.left=current} feature=OpMultiply) right=DivideExpression)*;

OpMultiply:
	'*';

DivideExpression returns Expression:
	ModuloExpression (=>({Operation.left=current} feature=OpDivide) right=ModuloExpression)*;

OpDivide:
	'/';

ModuloExpression returns Expression:
	UnaryOperation (=>({Operation.left=current} feature=OpModulo) right=UnaryOperation)*;

OpModulo:
	'%';

UnaryOperation returns Expression:
	{UnaryOperation} feature=OpUnary operand=PreIncrementOperation
	| PreIncrementOperation;
		
OpUnary:
	'!' | '-' | '~';
	
PreIncrementOperation returns Expression:
	=>({PreIncrementOperation} feature=OpIncrement operand=PostIncrementOperation) |
	PostIncrementOperation;
	
PostIncrementOperation returns Expression:
	=>({PostIncrementOperation} operand=MemberFeatureCall feature=OpIncrement) |
	MemberFeatureCall;
	
OpIncrement:
	'++' | '--';

/**********************
 * EXPRESSIONS - OTHER
 */

MemberFeatureCall returns Expression:
	PrimaryExpression 
	(=>({Assignment.assignable=current} '.' feature=[Feature|FeatureID] OpSingleAssign) value=Assignment
	|=>({ArrayAssignment.assigname=current} '[' feature=Expression ']' OpSingleAssign) value=Assignment
	|=>({MemberFeatureCall.target=current} '.') 
		feature=[Feature|FeatureID] (
			=>explicitOperationCall?='(' 
				(
					arguments+=Expression (',' arguments+=Expression)*
				)? 
			')'
		)?
	|=>({ArrayAccess.target=current})
		'[' feature=Expression ']' (
			=>explicitOperationCall?='(' 
				(
					arguments+=Expression (',' arguments+=Expression)*
				)? 
			')'
		)?
	)*
;

PrimaryExpression returns Expression:
	BlockExpression |
	ParenthesizedExpression |
	IfExpression |
	WhileExpression |
	DoWhileExpression |
	ForLoopExpression |
	ReturnExpression |
	BreakExpression |
	ContinueExpression |
	ThrowExpression |
	TryCatchExpression |
	SwitchExpression |
	FunctionExpression |
	FeatureCall |
	ConstructorCall |
	Literal
;

BlockExpression returns Expression: 
	{BlockExpression}
	'{'
		(expressions+=ExpressionInsideBlock ';'?)*
	'}';

ExpressionInsideBlock returns Expression:
	VariableDeclarations | Expression;

VariableDeclarations returns Expression:
	{VariableDeclarations} 'var' declarations+=VariableDeclaration (',' declarations+=VariableDeclaration)*;

VariableDeclaration returns VariableDeclaration:
	{VariableDeclaration} name=ValidID (':' type=TypeReference)? ('=' expression=Expression)?;

ParenthesizedExpression returns Expression:
	'(' Expression ')';

FunctionExpression returns Expression:
	{FunctionExpression} 'function' '(' (parameters+=OptionalParameter (',' parameters+=OptionalParameter)*)? ')' (':' returnType=TypeReference)?
		body=BlockExpression;

FeatureCall returns Expression:
	{FeatureCall}
	feature=[Feature|FeatureID]
	(=>explicitOperationCall?='(' 
		(arguments+=Expression)? (',' arguments+=Expression)*
	')')?; 

ConstructorCall returns Expression:
	{ConstructorCall}
	'new' constructor=ParameterizedTypeReference
	'(' 
		(arguments+=Expression)? (',' arguments+=Expression)*
	')';

/**********************
 * EXPRESSIONS - CONTROL FLOW
 */

IfExpression returns Expression:
	{IfExpression}
	'if' '(' if=Expression ')'
	then=Expression
	(=>(';'? 'else' else=Expression))?;
	
WhileExpression returns Expression:
	{WhileExpression}
	'while' '(' predicate=Expression ')'
		body=Expression;

DoWhileExpression returns Expression:
	{DoWhileExpression}
   'do'
       body=Expression
   'while' '(' predicate=Expression ')';

ForLoopExpression returns Expression:
	{ForLoopExpression}
	=>('for' '(' declaredParam=Parameter 'in' forExpression=Expression ')')
		body=Expression;

TryCatchExpression returns Expression:
	{TryCatchExpression}
	'try' 
		expression=Expression
	(
		(catchClauses+=CatchClause)+
	);
	
CatchClause:
	=>'catch' '(' declaredParam=Parameter ')' expression=Expression;

SwitchExpression returns Expression:
	{SwitchExpression}
	'switch' switch=Expression '{'
		(cases+=CasePart)+
		('default' ':' default=CasePartExpressions)?
	'}';

CasePart:
	=>'case' cases+=Expression ((',' cases+=Expression)+)? ':' then=CasePartExpressions;

CasePartExpressions:
	{CasePartExpressions} (expressions+=ExpressionInsideBlock ';'?)*;

ReturnExpression returns Expression :
	{ReturnExpression} 'return' (=>expression=Expression)?;

BreakExpression returns Expression:
	{BreakExpression} 'break';

ContinueExpression returns Expression:
	{BreakExpression} 'continue';

ThrowExpression returns Expression :
	{ThrowExpression} 'throw' expression=Expression;
	
/**********************
 * EXPRESSIONS - LITERALS
 */

Literal returns Expression:
	NullLiteral |
	StringLiteral |
	NumberLiteral |
	RegularExpressionLiteral |
	ArrayLiteral |
	ObjectLiteral
;

NullLiteral returns Expression:
	{NullLiteral} 'null';

NumberLiteral returns Expression:
	{NumberLiteral} value=Number;

Number hidden():
    =>(INT? '.' (INT|EXPONENT_FLOAT)) |
    HEX	|
    EXPONENT_FLOAT |
    INT;

StringLiteral returns Expression:
	{StringLiteral} value=STRING;

RegularExpressionLiteral returns Expression:
	{RegularExpressionLiteral} value=REGULAR_EXPRESSION;

ArrayLiteral returns Expression:
	{ArrayLiteral} '[' (elements+=Expression)? (',' elements+=Expression)* ']';

ObjectLiteral returns Expression:
	{ObjectLiteral} '{' elements+=ObjectElement (',' elements+=ObjectElement)* '}';

ObjectElement:
	key=ValidID ':' value=Expression;

/**********************
 * NAMES AND IDS
 */

QualifiedNameWithWildcard:
	QualifiedName '.*'?;

QualifiedName:
  ValidID ('.' ValidID)*;
  
ValidID:
	ID;

FeatureID:
	ValidID | 'super' | 'this';

/**********************
 * TERMINALS
 */

terminal ID:
	('a'..'z'|'A'..'Z'|'$'|'_') ('a'..'z'|'A'..'Z'|'$'|'_'|'0'..'9')* ;

// The hex and exponent float terminals are needed because we would otherwise get INT and ID
terminal EXPONENT_FLOAT:
	INT EXPONENT;

terminal fragment EXPONENT: 
	('e'|'E') ('+'|'-')? INT ;

terminal HEX returns ecore::EInt : 
	'0' ('x'|'X') HEX_DIGIT+ ;

terminal fragment HEX_DIGIT : 
	('0'..'9'|'a'..'f'|'A'..'F') ;
	
terminal INT returns ecore::EInt : 
	('0'..'9')+;

terminal REGULAR_EXPRESSION:
	'~/' ('\\/' | !'/')+ '/' ('i' | 'g' | 'm' | 's' | 'u')*;
	
terminal STRING: 
	'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
	"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
;
 
terminal ML_COMMENT:
	'/*' -> '*/';
	
terminal SL_COMMENT:
	'//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS:
	(' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER: 
	.;